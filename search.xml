<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>复盘</title>
      <link href="/2025/07/31/%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/07/31/%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计</title>
      <link href="/2025/07/31/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
      <url>/2025/07/31/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/概率论与数理统计.svg" alt="概率论与数理统计"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构真题</title>
      <link href="/2025/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9C%9F%E9%A2%98/"/>
      <url>/2025/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 热题 100</title>
      <link href="/2025/07/29/LeetCode%20%E7%83%AD%E9%A2%98%20100/"/>
      <url>/2025/07/29/LeetCode%20%E7%83%AD%E9%A2%98%20100/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">链表</h1><h2 id="160-相交链表---力扣leetcode"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&amp;envId=top-100-liked">160.相交链表 - 力扣（LeetCode）</a></h2><p>题意：输入两个链表，找出它们的第一个公共结点。当不存在公共节点时，返回空节点。</p><p>思路： 1. 用两个指针 p1，p2 分别指向两个链表 headA，headB的头结点，同时向后遍历。<br>2. 当指针到达链表末尾时，重新定位到另一个链表的头结点。<br>3. 当它们相遇时，所指向的结点就是第一个公共结点。</p><p><strong>解释</strong><br>设A链表的非公共部分长度为LA，B链表的非公共部分长度为LB，公共部分长度为C。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_9e36c2ea39-360截图20201206224658719.jpg" alt="360截图20201206224658719.jpg"></p><p>A链表总长度为LA + C，B链表总长度为LB + C。<br>当指针按照题解方式走下去，p1第二次走到公共节点的时候，走过的长度为LA + C+ LB，p2第二次走到公共节点的时候，走过的长度为LB + C + LA。p1p2走过的长度相等，p1 p2 相遇。<br>所以，当p1 p2 相遇（相等）的时候，指向的节点就是公共节点。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_09e842e839-1.jpg" alt="1.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_cb2baf2c39-7.jpg" alt="7.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/55289_cd9e63e539-13.jpg" alt="13.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_d1407a4739-16.jpg" alt="16.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/55289_d585778c39-20.jpg" alt="20.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_d89b017639-23.jpg" alt="23.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_dba646c839-26.jpg" alt="26.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_deecbe3e39-29.jpg" alt="29.jpg"><br><img src="https://cdn.acwing.com/media/article/image/2020/12/08/55289_e2831b8839-32.jpg" alt="32.jpg"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line">            <span class="keyword">if</span>(q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h2 id="234-回文链表---力扣leetcode"><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">234.回文链表 - 力扣（LeetCode）</a></h2><p>题意:给定一个链表要求判断链表节点是否构成回文链表</p><p>思路：将链表节点依次加入数组中，将问题转化为判断数组是否是回文数组，时间复杂度<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        {</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = res.<span class="built_in">size</span>() <span class="number">-1</span>; i &lt; j; i ++, j --)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(res[i] != res[j])</span><br><span class="line">            {</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>思路二：快慢指针</p><p>避免使用 O(n) 额外空间的方法就是改变输入。</p><p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p><p>该方法虽然可以将空间复杂度降到O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p><p>算法</p><p>整个流程可以分为以下五个步骤：</p><ol type="1"><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p><p>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            ListNode* nextTemp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);</span><br><span class="line">        ListNode* secondHalfEnd = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">        ListNode* l = head;</span><br><span class="line">        ListNode* r = secondHalfEnd;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag &amp;&amp; r != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val != r-&gt;val)</span><br><span class="line">                flag =  <span class="literal">false</span>;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h2 id="141-环形链表---力扣leetcode"><a href="https://leetcode.cn/problems/linked-list-cycle/submissions/648484902/?envType=study-plan-v2&amp;envId=top-100-liked">141.环形链表 - 力扣（LeetCode）</a></h2><p>题意：链表是否存在环路</p><p>思路：双指针，定义快慢指针，快指针每次移动两个节点，慢指针每次移动一个节点，每次判断快慢指针指向节点的下一个节点是否相同即可。时间复杂度<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>,这题与两链表是否有公共路径类似</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* low = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(low-&gt; next == fast-&gt;next)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h2 id="142-环形链表-ii---力扣leetcode"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&amp;envId=top-100-liked">142.环形链表 II - 力扣（LeetCode）</a></h2><ol type="1"><li><strong>快慢指针相遇时</strong>：当快慢指针相遇时，只能证明链表中有环，但相遇点不一定是环的入口节点。</li><li><strong>环的入口节点定位</strong>：根据 Floyd的算法，当快慢指针相遇后，将一个指针重新指向链表头部，然后两个指针以相同速度前进，再次相遇的点就是环的入口节点。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">                <span class="comment">// 有环，定位入口节点</span></span><br><span class="line">                ListNode* ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) {</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>考研算法全程训练营</title>
      <link href="/2025/07/25/%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E5%85%A8%E7%A8%8B%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
      <url>/2025/07/25/%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E5%85%A8%E7%A8%8B%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="考研算法全程训练营">考研算法全程训练营</h1><h1 id="第一周">第一周</h1><h2 id="数组折叠求和">数组折叠求和</h2><h2 id="统计目标字符">统计目标字符</h2><h2 id="第一个正元素"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3316">第一个正元素</a></h2><p>题意：求第一个正数对应的下标</p><p>思路1：枚举，当读入到第一个正数输出输出对应下标 O(n)</p><p>思路2：二分查找第一个正数的下标，二分下标即可</p><p>枚举代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N];</span><br><span class="line">int idx = -1;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    scanf("%d", &amp;n);</span><br><span class="line">    for(int i = 0; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        scanf("%d", &amp;a[i]);</span><br><span class="line">        if(a[i] &gt; 0)</span><br><span class="line">        {</span><br><span class="line">            idx = i;</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    if(idx == -1)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>二分代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250725230604119.png" alt="image-20250725230604119"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; <span class="number">0</span>) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(l == n - <span class="number">1</span> &amp;&amp; a[l] &lt; <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="交替最大最小元素"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3317">交替最大最小元素</a></h2><p>题意：根据题目给出的数组，交替输出最大最小值</p><p>思路：排序后，双指针i j分别指向最大最小值进行输出</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt;= j; i ++, j --)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(i != j)</span><br><span class="line">            cout &lt;&lt; a[j] &lt;&lt; <span class="string">" "</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" \n"</span>[j - i == <span class="number">1</span>];<span class="comment">//处理输出字符</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="第二周">第二周</h1><h2 id="统计区间正整数"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3319&amp;problemSubTab=solution&amp;problemSubId=1513870690">统计区间正整数</a></h2><p>题意如题</p><p>思路；前缀和，将整数全赋值1，负数为0，那么区间和就表示区间正整数的数量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = (a[i] &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        l ++, r ++;</span><br><span class="line">        cout &lt;&lt; a[r] - a[l - <span class="number">1</span>] &lt;&lt; endl;<span class="comment">//如果使用 cout 输出的话，换行使用 endl 可能会超时，建议使用 \n 提速。</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="最少纸币找零"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3320">最少纸币找零</a></h2><p>题意：</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250725233127127.png" alt="image-20250725233127127"></p><p>思路：贪心，先用面额大的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    y -= x;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    c = y / <span class="number">5</span>;</span><br><span class="line">    y %= <span class="number">5</span>;</span><br><span class="line">    b = y / <span class="number">2</span>;</span><br><span class="line">    y %= <span class="number">2</span>;</span><br><span class="line">    a = y;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="string">' '</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="奇偶消消栈">奇偶消消栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;                    <span class="comment">// 读取操作数个数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; st;              <span class="comment">// 定义栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) {</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;                <span class="comment">// 读取下一个数</span></span><br><span class="line">        st.<span class="built_in">push_back</span>(x);         <span class="comment">// 入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当栈顶有两个元素时尝试合并</span></span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">auto</span> u = st.<span class="built_in">back</span>(); st.<span class="built_in">pop_back</span>();   <span class="comment">// 取出并移除栈顶元素</span></span><br><span class="line">            <span class="keyword">auto</span> v = st.<span class="built_in">back</span>(); st.<span class="built_in">pop_back</span>();   <span class="comment">// 取出并移除次顶元素</span></span><br><span class="line">            <span class="keyword">if</span> (u % <span class="number">2</span> == v % <span class="number">2</span>) {</span><br><span class="line">                st.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(u - v));        <span class="comment">// 同奇偶则压入差值</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                st.<span class="built_in">push_back</span>(v);                 <span class="comment">// 不同奇偶则恢复原顺序</span></span><br><span class="line">                st.<span class="built_in">push_back</span>(u);</span><br><span class="line">                <span class="keyword">break</span>;                           <span class="comment">// 退出合并循环</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : st) {</span><br><span class="line">        sum += val;                <span class="comment">// 累加栈中元素</span></span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;          <span class="comment">// 输出结果并换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="总和受限队列"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3322">总和受限队列</a></h2><p>题意：<img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250726224309620.png" alt="image-20250726224309620"></p><p>思路：循环队列，res存放队列和，每次入队后判断队列和res是否大于k，大于则队头出队，折半入队，res也需要动态修改。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">LL res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">        res += x;</span><br><span class="line">        <span class="keyword">while</span>(res &gt; k)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res -= t;</span><br><span class="line">            t /= <span class="number">2</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t);</span><br><span class="line">            res += t;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">" \n"</span>[q.<span class="built_in">size</span>() == <span class="number">1</span>];</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="第三周">第三周</h1><h2 id="链表最大节点复制"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3323">链表最大节点复制</a></h2><p>题意：找到链表最大值，并在最大的节点后插入一个最大的节点</p><p>思路：遍历两次链表，第一次找最大值，第二次遍历，遍历到最大值节点，进行插入</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param head: 链表的头节点</span></span><br><span class="line"><span class="comment"> * @return: 直接在原链表上修改，不需要返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertAfterMaxData</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">    ListNode* currentNode = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> maxVal = head-&gt;next-&gt;val;</span><br><span class="line">    <span class="keyword">while</span>(currentNode != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(maxVal &lt; currentNode-&gt;val)</span><br><span class="line">        {</span><br><span class="line">            maxVal = currentNode-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    currentNode = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(currentNode != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(maxVal == currentNode-&gt;val)</span><br><span class="line">        {</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(maxVal);</span><br><span class="line">            newNode-&gt;next = currentNode-&gt;next;</span><br><span class="line">            currentNode-&gt;next = newNode;</span><br><span class="line">            currentNode = newNode-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="字典序分治交换"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3324">字典序分治交换</a></h2><p>题意：</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250728203915528.png" alt="image-20250728203915528"></p><p>思路：<img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250728203939173.png" alt="image-20250728203939173"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">string OP(string &amp;s)</span><br><span class="line">{</span><br><span class="line">    int n = s.size();</span><br><span class="line">    if(n &lt; 2)</span><br><span class="line">    {</span><br><span class="line">        return s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int midIdx = n / 2;</span><br><span class="line">    string l, r, mid = "";</span><br><span class="line">    if(n % 2 == 0)</span><br><span class="line">    {</span><br><span class="line">        l = s.substr(0, midIdx);</span><br><span class="line">        r = s.substr(midIdx, n - midIdx);</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        l = s.substr(0, midIdx);</span><br><span class="line">        mid = s[midIdx];</span><br><span class="line">        r = s.substr(midIdx + 1, n - midIdx - 1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string lRes = OP(l);</span><br><span class="line">    string rRes = OP(r);</span><br><span class="line">    if(lRes &lt; rRes)</span><br><span class="line">    {</span><br><span class="line">        swap(lRes, rRes);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return lRes + mid + rRes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    // OP(s);</span><br><span class="line">    s = OP(s);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; "\n";</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="第七周">第七周</h1><h2 id="012串"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3340">012串</a></h2><p>题意：输出长度为n的串的所有可能结果，每一位只能是0、1、2</p><p>思路：DFS</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// int cnt = 0;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// cnt ++;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            cout &lt;&lt; path[i];</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!st[u][i])</span><br><span class="line">        {</span><br><span class="line">            st[u][i] = <span class="literal">true</span>;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            path[u] = <span class="number">0</span>;</span><br><span class="line">            st[u][i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="第十周">第十周</h1><h2 id="判断完全二叉树"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3352">判断完全二叉树</a></h2><p>题意：给出书的根节点，判断是否是完全二叉树</p><p>思路：BFS</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250726230254187.png" alt="image-20250726230254187"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param root: 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * @return: 如果是完全二叉树返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    queue&lt;TreeNode *&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> foundNullptr = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            foundNullptr = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(foundNullptr)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t -&gt; left);</span><br><span class="line">            q.<span class="built_in">push</span>(t -&gt; right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="第十一周">第十一周</h1><h2 id="度最大的顶点"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3356">度最大的顶点</a></h2><p>题目：给定一个邻接表表示的图，求度最大的顶点</p><p>思路：邻接表图，出度即为节点行不唯一的数，入度为列不唯一的数量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param G: 邻接矩阵，表示无向图，按二维数组的方式用下标即可访问内部元素</span></span><br><span class="line"><span class="comment"> * @param n: 图中顶点的数量</span></span><br><span class="line"><span class="comment"> * @return: 度最大的顶点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxDegreeVertex</span><span class="params">(<span class="type">int</span>** G, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, max_degree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) d += G[i][j] + G[j][i];</span><br><span class="line">        <span class="keyword">if</span>(d &gt; max_degree)</span><br><span class="line">        {</span><br><span class="line">            max_degree = d;</span><br><span class="line">            res = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="双子连通块"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3357">双子连通块</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param G: 邻接矩阵，表示无向图，按二维数组的方式用下标即可访问内部元素</span></span><br><span class="line"><span class="comment"> * @param n: 图中顶点的数量</span></span><br><span class="line"><span class="comment"> * @return: 返回图中双子连通块的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countTwinConnectedComponents</span><span class="params">(<span class="type">int</span>** G, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        degree[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">        {</span><br><span class="line">            degree[i] += G[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> twinCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(degree[i] == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(G[i][j] == <span class="number">1</span> &amp;&amp; degree[j] == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    twinCount ++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> twinCount;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="最大连通块"><a href="https://sunnywhy.com/camp/3415/model/4144?itemId=3358">最大连通块</a></h2><p>思路：<img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250730222519239.png" alt="image-20250730222519239"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param G: 邻接矩阵，表示无向图，按二维数组的方式用下标即可访问内部元素</span></span><br><span class="line"><span class="comment"> * @param n: 图中顶点的数量</span></span><br><span class="line"><span class="comment"> * @return: 返回图中顶点数量最多的连通块中的顶点数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> **G, vector&lt;<span class="type">bool</span>&gt; &amp;visited, <span class="type">int</span> n, <span class="type">int</span> &amp;count)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(G[u][v] == <span class="number">1</span> &amp;&amp; !visited[v])</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">DFS</span>(v, G, visited, n, count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestConnectedComponent</span><span class="params">(<span class="type">int</span>** G, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(i, G, visited, n, count);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxCount)</span><br><span class="line">            {</span><br><span class="line">                maxCount = count;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxCount;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学知识结构</title>
      <link href="/2025/07/13/%E9%AB%98%E6%95%B0%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84/"/>
      <url>/2025/07/13/%E9%AB%98%E6%95%B0%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学知识结构">高等数学知识结构</h1><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250713132719200.png" alt="image-20250713132719200"></p><h2 id="第十三讲-多元函数微分学">第十三讲 多元函数微分学</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250713132622422.png" alt="image-20250713132622422"></p><h2 id="第十六讲-无穷级数">第十六讲 无穷级数</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250717110230119.png" alt="image-20250717110230119"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250717110408054.png" alt="image-20250717110408054"></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学公式总结</title>
      <link href="/2025/07/13/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2025/07/13/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学">高等数学</h1><h2 id="定积分计算">定积分计算</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250713143331522.png" alt="image-20250713143331522"></p><h3 id="欧拉函数">欧拉函数</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250713143402787.png" alt="image-20250713143402787"></p><h1 id="线性代数">线性代数</h1><h1 id="概率论与数理统计">概率论与数理统计</h1>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2025/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2025/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理">计算机组成原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711165131829.png" alt="image-20250711165131829"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711200111849.png" alt="image-20250711200111849"></p><h2 id="第一章-计算机系统概述">第一章 计算机系统概述</h2><h3 id="冯诺依曼机特点">冯诺依曼机特点</h3><ol type="1"><li>存储程序</li><li>计算机由运算器，控制器，存储器，输入设备，输出设备5大部件组成</li><li>指令和数据同等地位存储在存储器中</li><li>指令数据均用二进制代码表示</li><li>指令由操作码地址码组成，操作码指出操作类型，地址码指出操作数地址</li><li>*以运算器为核心</li></ol><h3 id="mar-mdr">MAR MDR</h3><p>MAR：存储器地址寄存器，反应存储单元个数，用于寻址，10位，即<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.461ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 4623.7 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"></path></g></g></g></svg></mjx-container></span>个存储单元,长度与PC相同MDR：存储器数据寄存器，位数表示存储字长</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711170525306.png" alt="image-20250711170525306"></p><p>运算器核心 ALU（算数逻辑单元</p><p>控制器由PC（程序计数器、IR（指令寄存器、CU（控制单元 组成</p><p>CPU = 运算器+控制器（cache MAR MDR 其实也在CPU中</p><p><img src="C:/Users/24824/AppData/Roaming/Typora/typora-user-images/image-20250711191801798.png" alt="n"></p><p>八位表示机器字长8位，一次可以处理8位的数据</p><p>16表示地址码的长度，因此该系统有<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.592ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 5123.7 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container></span>个地址空间</p><h3 id="存取速度-寄存器在cpu内部最快cachesram内存一般是dram">存取速度寄存器（在CPU内部最快）&gt;Cache（SRAM&gt;内存(一般是DRAM)</h3><h3 id="cpu性能三要素主频cpi指令条数">CPU性能三要素：主频、CPI、指令条数</h3><h3 id="cpu执行时间cpu时钟周期数主频--指令数--cpi--主频">CPU执行时间=CPU时钟周期数/主频= （指令数 * CPI） / 主频</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711201213583.png" alt="image-20250711201213583"></p><h3 id="计算程序运行花费时间">计算程序运行花费时间</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711201739513.png" alt="image-20250711201739513"></p><p>总时钟周期数=CPI*指令数=300</p><p>总时间=总时钟周期数/主频 = 0.3s</p><p>执行程序耗时=CPU运行时间</p><h3 id="cpu性能指标">CPU性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711202158117.png" alt="image-20250711202158117"></p><h3 id="系统整体的性能指标">系统整体的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711202656436.png" alt="image-20250711202656436"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250711204121477.png" alt="image-20250711204121477"></p><h2 id="第二章-数据的表示和运算">第二章 数据的表示和运算</h2><h3 id="原码">原码</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716173125773.png" alt="image-20250716173125773"></p><p><strong>原码0的表示有两种</strong></p><h3 id="反码">反码</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716173213237.png" alt="image-20250716173213237"></p><h3 id="补码">补码</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716173310460.png" alt="image-20250716173310460"></p><h4 id="warning原码转换成补码和补码转换成原码操作一样都是除符号位以外全部取反加1"><span class="emoji" data-emoji="warning">⚠️</span>原码转换成补码和补码转换成原码操作一样，都是除符号位以外全部取反加1</h4><h3 id="移码只能表示整数">移码（只能表示整数</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716173937613.png" alt="image-20250716173937613"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716173947825.png" alt="image-20250716173947825"></p><h3 id="tips">Tips</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716174823142.png" alt="image-20250716174823142"></p><h3 id="总结">总结</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250716174935345.png" alt="image-20250716174935345"></p><h3 id="补码加减溢出判断三种方法star2">补码加减溢出判断三种方法<span class="emoji" data-emoji="star2">🌟</span></h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250717155758232.png" alt="image-20250717155758232"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250717160012050.png" alt="image-20250717160012050"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250717160257128.png" alt="image-20250717160257128"></p><h3 id="无符号加减运算以及溢出判断">无符号加减运算以及溢出判断</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250717155018810.png" alt="image-20250717155018810"></p><h3 id="不理解知识点汇总">不理解知识点汇总</h3><h4 id="什么时候左规什么时候右规">什么时候左规，什么时候右规。</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250720145615620.png" alt="image-20250720145615620"></p><h4 id="ieee非规格化的情况">IEEE非规格化的情况</h4><p>阶码为0，尾数不为0</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250720153101180.png" alt="image-20250720153101180"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250720154129012.png" alt="image-20250720154129012"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250720162400614.png" alt="image-20250720162400614"></p><h4 id="小端点存储方式">小端点存储方式</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250720162843691.png" alt="image-20250720162843691"></p><h4 id="ieee表述浮点数">IEEE表述浮点数</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250720172311199.png" alt="image-20250720172311199"></p><h2 id="第三章存储系统">第三章存储系统</h2><h3 id="判断金属引脚">判断金属引脚</h3><h3 id="随机存储">随机存储</h3><h3 id="辨别内存外存辅存cache区别以及读写速度">辨别内存、外存，辅存，cache区别以及读写速度</h3><h3 id="dram刷新技术地址复用技术">DRAM刷新技术、地址复用技术</h3>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习1.1卷积神经网络基础</title>
      <link href="/2025/07/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/07/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习">深度学习</h1><h1 id="11卷积神经网络基础">1.1卷积神经网络基础</h1><h2 id="卷积神经网络">卷积神经网络</h2><p>包含卷积层的网络都可以理解为卷积神经网络</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708000749376.png" alt="image-20250708000749376"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708000829085.png" alt="image-20250708000829085"></p><p>卷积神经网络实例：图像分类、图像检索、目标检测、图像分割、无人驾驶、图像描述，图像风格迁移…</p><h2 id="全连接层">全连接层</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001059546.png" alt="image-20250708001059546"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001134354.png" alt="image-20250708001134354"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001232556.png" alt="image-20250708001232556"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001317758.png" alt="image-20250708001317758"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001335128.png" alt="image-20250708001335128"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001353917.png" alt="image-20250708001353917"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001435555.png" alt="image-20250708001435555"></p><h2 id="卷积层">卷积层</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001454307.png" alt="image-20250708001454307"></p><p>卷积目的：图像特征提取</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001607460.png" alt="image-20250708001607460"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708001811754.png" alt="image-20250708001811754"></p><h2 id="池化层">池化层</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708002004164.png" alt="image-20250708002004164"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708002021287.png" alt="image-20250708002021287"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 图像分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408重难点以及错题整理</title>
      <link href="/2025/07/07/408%E9%87%8D%E9%9A%BE%E7%82%B9%E5%8F%8A%E9%94%99%E9%A2%98/"/>
      <url>/2025/07/07/408%E9%87%8D%E9%9A%BE%E7%82%B9%E5%8F%8A%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="408重难点以及错题整理">408重难点以及错题整理</h1><p>[toc]</p><h2 id="未理解的概念">未理解的概念</h2><table><thead><tr><th>内容</th><th>备注</th><th></th></tr></thead><tbody><tr><td>图的四种存储，邻接多重表，十字链表</td><td></td><td></td></tr><tr><td>计算AOE图Ve Vl 关键路径等</td><td></td><td></td></tr><tr><td>邻接表/矩阵 dfs bfs时空复杂度</td><td></td><td></td></tr><tr><td>平衡树AVL BBT(balance binary tree)的插入删除以及构造</td><td></td><td></td></tr><tr><td>红黑树的插入和删除</td><td></td><td></td></tr><tr><td>二叉排序树的删除</td><td></td><td></td></tr><tr><td>红黑树的定义</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="树">树</h2><h3 id="树的性质">树的性质：</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250626232854274.png" alt="image-20250626232854274"></p><h3 id="错难题-p131">错难题 P131</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250627000103137.png" alt="image-20250627000103137"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250627000126721.png" alt="image-20250627000126721"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250627001220419.png" alt="image-20250627001220419"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250627001248811.png" alt="image-20250627001248811"></p><hr><h2 id="图">图</h2><h3 id="概念术语只记录不熟的"><strong>概念术语（只记录不熟的：</strong></h3><h4 id="简单图无重边无自环">简单图：无重边，无自环</h4><h4 id="多重图有重边有自环">多重图：有重边/有自环</h4><h4 id="完全图又称简单完全图">完全图：又称简单完全图</h4><p>对于无向图中任意两点有边，则称为完全图，n个点边数<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="7.004ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 3095.9 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mo" transform="translate(1100,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1489,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2089,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2867,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3367,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(1371.2,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="2855.9" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></span></p><p>对于有向图中，n个点的边数为<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.509ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4644.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mo" transform="translate(1544.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1933.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2755.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3755.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4255.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p><h4 id="子图">子图</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250704180904507.png" alt="image-20250704180904507"><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250704180916083.png" alt="image-20250704180916083"></p><h4 id="连通分量">连通分量</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250704181204444.png" alt="image-20250704181204444"></p><h4 id="强连通图强连通分量">强连通图、强连通分量</h4><p>人话解释，互通就是强连通，所有顶点都互通即为前连通图。</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250704181250520.png" alt="image-20250704181250520"></p><p><strong>最少n条边，环状</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250704181519045.png" alt="image-20250704181519045"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706164246453.png"></p><h2 id="62">6.2</h2><h3 id="图的四种存储方式总结">图的四种存储方式总结</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706183039493.png" alt="image-20250706183039493"></p><h3 id="15-邻接表">15 邻接表</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706183614808.png" alt="image-20250706183614808"></p><h2 id="63">6.3</h2><h3 id="04-邻接表遍历">04 邻接表遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706184705206.png" alt="image-20250706184705206"></p><h3 id="07-无向图深度优先遍历">07 无向图深度优先遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706184939734.png" alt="image-20250706184939734"></p><h3 id="13-生成树-连通分量">13 生成树 连通分量</h3><p><strong>生成树即极小连通子图，无环</strong></p><p><strong>连通分量是无向图中的极大连通子图</strong></p><p><strong>极大连通子图意思是，图中的任意两点均有路径</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706185523631.png" alt="image-20250706185523631"></p><h2 id="646">6.4.6</h2><h3 id="23求关键路径">23求关键路径</h3><p><strong>画图，写出最早最晚开始时间，找到关键节点，选出一条关键路径。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706164250426.png" alt="image-20250706164250426"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706164636704.png" alt="image-20250706164636704"></p><h3 id="事件v活动a相关考点">事件v,活动a相关考点</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706165715236.png" alt="image-20250706165715236"></p><h3 id="关键路径">关键路径</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706170220030.png" alt="image-20250706170220030"></p><h3 id="29-模拟dijkstra最短路">29 模拟dijkstra最短路</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706170758487.png" alt="image-20250706170758487"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706170730077.png" alt="image-20250706170730077"></p><h3 id="45-求事件余量">45 求事件余量</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706172824665.png" alt="image-20250706172824665"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706172846136.png" alt="image-20250706172846136"></p><h3 id="aov和aoe区分">AOV和AOE区分</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706172959080.png" alt="image-20250706172959080"></p><h2 id="第七章-查找">第七章 查找</h2><h3 id="考纲">考纲</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706191335793.png" alt="image-20250706191335793"></p><h3 id="查找知识框架">查找知识框架</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250706191315089.png" alt="image-20250706191315089"></p><h3 id="二叉排序树">二叉排序树</h3><p>左子树节点的致&lt;右节点的值&lt;右节点的值</p><h3 id="平衡二叉树">平衡二叉树</h3><p>Balance Binay Tree 又称AVL树，不用好奇，AVL是发明人名字缩写。任意节点左右子树高度差不超过1.</p><h3 id="平衡二叉树的删除">平衡二叉树的删除</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710135335236.png" alt="image-20250710135335236"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710140323088.png" alt="image-20250710140323088"></p><p>前驱节点:左子树最右边</p><p>后继节点：右子树最左边</p><h3 id="红黑树">红黑树</h3><h4 id="为什么要有红黑树">为什么要有红黑树</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710140848332.png" alt="image-20250710140848332"></p><h4 id="红黑树的定义">红黑树的定义</h4><p>口诀：</p><p>左根右 根叶黑</p><p>不红红 黑路同</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710141258859.png" alt="image-20250710141258859"></p><h4 id="黑高">黑高</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710141520743.png" alt="image-20250710141520743"></p><h3 id="性质">性质</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710141630832.png" alt="image-20250710141630832"></p><h3 id="红黑树的插入">红黑树的插入</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710141931775.png" alt="image-20250710141931775"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710142852524.png" alt="image-20250710142852524"></p><h3 id="红黑树的删除">红黑树的删除</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710143000016.png" alt="image-20250710143000016"></p><h3 id="734-09">7.3.4 09</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707233816810.png" alt="image-20250707233816810"></p><h3 id="11">11</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707234411132.png" alt="image-20250707234411132"></p><h3 id="12">12</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707234451128.png" alt="image-20250707234451128"></p><h3 id="13-平衡二叉树形态">13 平衡二叉树形态</h3><p>考虑平衡二叉树，一定要考虑左右子树，因为平衡二叉树本身就是一个递归的结构</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707234639083.png" alt="image-20250707234639083"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707235410526.png" alt="image-20250707235410526"></p><h3 id="b树b树">B树，B+树</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710155922241.png" alt="image-20250710155922241"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710160626425.png" alt="image-20250710160626425"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710160751908.png" alt="image-20250710160751908"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710160856243.png" alt="image-20250710160856243"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710161141866.png" alt="image-20250710161141866"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710161229459.png" alt="image-20250710161229459"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710161444744.png" alt="image-20250710161444744"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710162207039.png" alt="image-20250710162207039"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710162906801.png" alt="image-20250710162906801"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710163156956.png" alt="image-20250710163156956"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710163353746.png" alt="image-20250710163353746"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710163407803.png" alt="image-20250710163407803"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710163606929.png" alt="image-20250710163606929"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710163718981.png" alt="image-20250710163718981"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710163953381.png" alt="image-20250710163953381"></p><h3 id="散列表">散列表</h3><h4 id="装填因子">装填因子</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710165748618.png" alt="image-20250710165748618"></p><h4 id="平方探测法">平方探测法</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710165959343.png" alt="image-20250710165959343"></p><h4 id="失败的平均查找长度">失败的平均查找长度</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710170358394.png" alt="image-20250710170358394"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710170503796.png" alt="image-20250710170503796"></p><h4 id="23-开放定址法-删除逻辑删除-查找失败平均长度">23 开放定址法删除（逻辑删除）， 查找失败平均长度</h4><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710171127781.png" alt="image-20250710171127781"></p><h2 id="第八章-排序">第八章 排序</h2><h3 id="-各种排序算法的性质">* 各种排序算法的性质</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250713155248436.png" alt="image-20250713155248436"></p><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><ul><li><p>最好情况下：表中元素有序，每次插入仅需要比较一次，不需要移动，时间复杂度<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p></li><li><p>最坏情况下：逆序，时间复杂度<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p></li></ul><h3 id="折半插入排序">折半插入排序</h3><p>仅适用于顺序存储的线性表</p><h3 id="希尔排序">希尔排序</h3><h4 id="基于插入排序但不稳定算法">基于插入排序，但不稳定算法</h4><h3 id="希尔排序比较次数计算">希尔排序比较次数计算</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710175054191.png" alt="image-20250710175054191"></p><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><h3 id="快速排序">快速排序</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710203738546.png" alt="image-20250710203738546"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710204138783.png" alt="image-20250710204138783"></p><h3 id="堆排序">堆排序</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710222929871.png" alt="image-20250710222929871"></p><p>第一步：先画完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710222959010.png" alt="image-20250710222959010"></p><p>从编号是n/2节点开始比较（最后一个有孩子的节点</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710223200334.png" alt="image-20250710223200334"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250710225448003.png" alt="image-20250710225448003"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用的机器学习课程</title>
      <link href="/2025/07/07/%E5%AE%9E%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/07/07/%E5%AE%9E%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="实用的机器学习课程">实用的机器学习课程</h1><p>[toc]</p><h2 id="监督学习">监督学习</h2><ol type="1"><li>分类</li><li>回归</li></ol><h3 id="basic-concepts-of-supervised-learning">Basic Concepts ofSupervised Learning</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707190511710.png" alt="image-20250707190511710"></p><p>Sample，example, instance</p><p>Features, representations, predictiors</p><h3 id="when-should-we-use-ml">When should we use ML</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707190648999.png" alt="image-20250707190648999"></p><h3 id="what-is-a-typical-pipline-of-ml">What is a typical pipline ofML</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707190930188.png" alt="image-20250707190930188"></p><p>Define A ML problem -&gt; Construct Dataset -&gt; Transform data&amp;get features -&gt; Design &amp; train a model -&gt; Use the modelto predict</p><h3 id="a-toy-example">A toy example</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707191108817.png" alt="image-20250707191108817"></p><ol type="1"><li><p>Define a ML problem</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707191324220.png" alt="image-20250707191324220"></p></li><li><p>Construct dataset</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707191356982.png" alt="image-20250707191356982"></p></li><li><p>Transform data</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707191442605.png" alt="image-20250707191442605"></p></li><li><p>Design % train a model(Training)</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707191541630.png" alt="image-20250707191541630"></p></li><li><p>Use the model to predict</p><p><img src="C:/Users/24824/AppData/Roaming/Typora/typora-user-images/image-20250707191621381.png" alt="image-20250707191621381"></p></li></ol><h3 id="改进">改进</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707191920177.png" alt="image-20250707191920177"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707192152931.png" alt="image-20250707192152931"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707192207430.png" alt="image-20250707192207430"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707192238433.png" alt="image-20250707192238433"></p><h3 id="generalization-泛化">Generalization 泛化</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707192414003.png" alt="image-20250707192414003"></p><h3 id="泛化测试集上的表现">泛化：测试集上的表现</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707192538277.png" alt="image-20250707192538277"></p><h3 id="bias">bias:</h3><h3 id="variance">Variance:</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250707192620796.png" alt="image-20250707192620796"></p><h3 id="define-a-ml-problem">Define a ML problem</h3><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708165901745.png" alt="image-20250708165901745"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708170304933.png" alt="image-20250708170304933"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708170340574.png" alt="image-20250708170340574"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708170607135.png" alt="image-20250708170607135"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708170643078.png" alt="image-20250708170643078"></p><p>useful features</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708171051852.png" alt="image-20250708171051852"></p><p>User features</p><p>Video features</p><p>Context</p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708171418477.png" alt="image-20250708171418477"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708171709844.png" alt="image-20250708171709844"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708172009713.png" alt="image-20250708172009713"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708172145016.png" alt="image-20250708172145016"></p><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250708172230208.png" alt="image-20250708172230208"></p><h2 id="无监督学习">无监督学习</h2><ol type="1"><li>聚类</li><li>降维</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学重点知识记忆</title>
      <link href="/2025/07/06/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BF%86/"/>
      <url>/2025/07/06/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="考研数学重点知识记忆">考研数学重点知识记忆</h1><h2 id="第二章-数列极限">第二章 数列极限</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250629131322227.png" alt="image-20250629131322227"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250629131337142.png" alt="image-20250629131337142"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250629133157.png" alt="20250629133157"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250629133124.png" alt="20250629133124"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250629140233.png" alt="20250629140233"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250629140826.png" alt="20250629140826"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250629140922.png" alt="20250629140922"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250629142041.png" alt="20250629142041"></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408每日一题</title>
      <link href="/2025/06/19/408%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2025/06/19/408%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="倒计时">倒计时</h1><h2 id="今日倒计时184天">今日倒计时184天</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/d3b877c9f4707f9288c9ff89c7616565.png" alt="d3b877c9f4707f9288c9ff89c7616565"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/f3f137da4f0a27d56830533ba32edfc6.png" alt="f3f137da4f0a27d56830533ba32edfc6"></p><h2 id="今日倒计时183天">今日倒计时183天</h2><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/e7701186cf0e773dda849ed11d6d4fb0.png" alt="e7701186cf0e773dda849ed11d6d4fb0"> <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/bc9a313c0c85f18f1286e01c520556ac.png" alt="bc9a313c0c85f18f1286e01c520556ac"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尤克里里学习</title>
      <link href="/2025/04/06/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/06/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="尤克里里学习">尤克里里学习</h1><h2 id="colorgreen尤克里里结构"><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="13.575ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 6000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle" fill="green" stroke="green"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">尤</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">克</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">里</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">里</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">结</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">构</text></g></g></g></g></g></svg></mjx-container></span></h2><p>尤克里里的结构与吉他基本相同，三大组部分从上到下分别为:琴头，琴颈，琴身。 <img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062041957.png"></p><h2 id="colorgreen持琴姿势"><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 4000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle" fill="green" stroke="green"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">持</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">琴</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">姿</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">势</text></g></g></g></g></g></svg></mjx-container></span></h2><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062046328.png">琵琶式持琴法:适合初学者使用的持琴方法，更容易观察琴颈、品格和左手指法，也是标准的尤克里里持琴方法。该持琴法是需要左手对琴颈进行托举的，在跨度较大的和弦转换情况下，左手松开琴头会往下掉，无法解放左手。</p><h2 id="colorgreen基础乐理"><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 4000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle" fill="green" stroke="green"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">基</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">础</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">乐</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">理</text></g></g></g></g></g></svg></mjx-container></span></h2><h3 id="四线谱">四线谱</h3><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062048215.png"></p><h3 id="音符与拍子">音符与拍子</h3><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062048519.png">以4/4拍为例:以4分音符作为一个基本单位为一拍，弹奏的时候可以通过左脚打拍子，脚尖向下落地再抬起回到原位，即为一拍。音符都拥有基本规律，如4/4拍四分音符就是一拍弹一个音，八分音符就是一拍弹两个音等，音符弹奏时要遵循音符基本规律，但拍子的速度可以通过自身需求或节拍器加以调节快慢和控制。<img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062049784.png"></p><h2 id="colorgreen单音练习"><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 4000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle" fill="green" stroke="green"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">单</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">音</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">练</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">习</text></g></g></g></g></g></svg></mjx-container></span></h2><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062050930.png"></p><h3 id="一指法">一指法</h3><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062051046.png"></p><h3 id="左手练习">左手练习</h3><p>把三个左手手指(食指、中指、无名指)分别分配到尤克里里的一品、二品、三品的指板上，弹出动听的旋律。</p><h4 id="c大调练习">C大调练习</h4><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202504062052450.png"></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> 尤克里里 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 尤克里里 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>达芬奇学习</title>
      <link href="/2025/01/09/%E8%BE%BE%E8%8A%AC%E5%A5%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/09/%E8%BE%BE%E8%8A%AC%E5%A5%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>picgo 上传图片快捷键 ctrl + alt + u/ ctrl shift p</strong><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/达芬奇学习思维导图.jpg" alt="达芬奇学习思维导图"></p><hr><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202501112332508.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 剪辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 达芬奇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星轨教程</title>
      <link href="/2024/12/01/%E6%98%9F%E8%BD%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2024/12/01/%E6%98%9F%E8%BD%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="如何拍摄星轨的解说稿">如何拍摄星轨的解说稿</h3><p>大家好，今天我将为大家介绍如何拍摄星轨。星轨是星空摄影中技术要求较低的一种题材，几乎任何设备都可以拍摄，哪怕是手机。</p><hr><h4 id="一拍摄前的准备">一、拍摄前的准备</h4><ol type="1"><li><strong>地点选择</strong>：虽然星轨拍摄不太挑环境，但尽量选择空气质量好的地方，减少云、沙尘和强光干扰。光污染和月亮影响较小，但避免近距离的灯光更理想。</li><li><strong>设备</strong>：<ul><li><strong>相机或手机</strong>：近10年生产的相机通常带有间隔拍摄功能。</li><li><strong>三脚架</strong>：用于固定相机。</li><li><strong>快门线</strong>（若没有间隔拍摄功能）。</li><li><strong>镜头清理工具</strong>：避免拍摄时出现光斑。</li></ul></li></ol><hr><h4 id="二拍摄步骤">二、拍摄步骤</h4><ol type="1"><li><p><strong>安装设备</strong>：将相机稳固在三脚架上，选择一个固定的拍摄角度。</p></li><li><p><strong>设置参数</strong>：</p><ul><li><strong>对焦</strong>：手动对焦，将画面放大，调整对焦环，直至星星变得最小。</li><li><strong>模式</strong>：使用M档。</li><li><strong>快门时间</strong>：设为30秒。</li><li><strong>光圈</strong>：光圈越大越好，F4也能满足要求。</li><li><strong>ISO</strong>：建议使用自动，观察相机自动选择的亮度效果，调整为合适的值。例如，如果ISO100亮度合适就直接使用，但若画面过曝，可以缩短快门时间或减小光圈。</li></ul></li><li><p><strong>间隔拍摄</strong>：</p><ul><li>开启相机的间隔拍摄功能，设置拍摄间隔与快门时间一致（如30秒）。</li><li>如果相机没有间隔拍摄功能，可使用快门线代替。</li><li>确保拍摄时间尽可能长，至少一个小时，以捕捉足够长的星轨。</li></ul></li><li><p><strong>关闭长曝光降噪</strong>：</p><ul><li>长曝光降噪会在每张照片后额外耗费时间进行降噪，影响星轨的连续性，因此需要关闭。</li></ul></li><li><p><strong>图片格式</strong>：将相机的照片保存为RAW格式，便于后期调整。</p></li></ol><hr><h4 id="三后期处理">三、后期处理</h4><ol type="1"><li><p><strong>图片导入</strong>：</p><ul><li>使用软件（如Photoshop或Lightroom），将所有拍摄的照片导入。</li><li>打开第一张照片，在Camera Raw滤镜中调整。</li></ul></li><li><p><strong>调整参数</strong>：</p><ul><li><strong>基本调整</strong>：适当提升曝光，让星点更亮，与背景形成对比。</li><li><strong>色温调整</strong>：使用吸管工具选择图片中灰色的部分进行自动校准，或手动调整。</li><li><strong>对比增强</strong>：通过清晰度、纹理等选项，让星轨和环境更突出。</li><li><strong>曲线调整</strong>：压暗天空的暗部，提升亮部对比，使星轨更明显。</li></ul></li><li><p><strong>同步设置</strong>：</p><ul><li>将第一张照片的调整同步到所有照片。</li><li>导出为JPG格式，便于后续堆叠。</li></ul></li><li><p><strong>星轨堆叠</strong>：</p><ul><li>在PS中，使用脚本功能将所有图片载入为图层。</li><li>选择所有图层后，将混合模式设置为“变亮”。</li><li>星轨会自动生成。</li></ul></li><li><p><strong>柔化星轨</strong>：</p><ul><li>为星轨开头和结尾的照片添加透明度递增或递减效果（例如第一张设置透明度为10%，第二张为20%，以此类推），使星轨的起始和结束更加自然。</li></ul></li></ol><hr><h4 id="四拍摄注意事项">四、拍摄注意事项</h4><ol type="1"><li><strong>避免光斑</strong>：清理镜头灰尘，并尽量避免正对灯光。</li><li><strong>调整环境亮度</strong>：在后期中可通过调节混色器，适当降低建筑物等橙色部分的亮度，让星轨更加突出。</li><li><strong>色彩处理</strong>：降低天空蓝色的饱和度，避免画面过于夸张。</li></ol><hr><p>通过以上步骤，无论是在专业设备还是普通环境下，大家都可以轻松拍摄出效果惊艳的星轨照片。希望这些技巧对大家有所帮助，期待看到你们的作品！</p><p>谢谢大家！</p><h1 id="讲解二">讲解二</h1><h3 id="如何拍摄星轨">如何拍摄星轨</h3><p>大家好！<br>今天我将向大家介绍如何拍摄星轨。虽然我自己还在学习的过程中，但希望能分享一些实用的经验和技巧。如果有不足之处，欢迎指正。</p><hr><h4 id="一前期准备">一、前期准备</h4><ol type="1"><li><p><strong>设备准备</strong>：</p><ul><li><strong>三脚架</strong>：尽量选择稳定性高的三脚架。如果没有，可以找到能够牢固固定相机的方式，避免晃动。</li><li><strong>相机</strong>：任何具有手动模式的相机都可以使用。确保电池充足，最好带备用电池或充电宝。检查内存卡容量是否足够。</li><li><strong>快门线或延时功能</strong>：如果相机支持内置延时功能，例如Sony A6400，就不需要额外的快门线。</li></ul></li><li><p><strong>拍摄位置</strong>：</p><ul><li>选择一个远离光污染的地方。山区、沙漠或偏远的郊区是理想选择。</li><li>尽量在晴朗无云的夜晚拍摄，并提前查询星象，寻找合适的星轨方向。</li></ul></li></ol><hr><h4 id="二拍摄设置">二、拍摄设置</h4><ol type="1"><li><p><strong>手动对焦</strong>：</p><ul><li>切换到手动对焦模式，可以通过放大画面或使用峰值对焦功能调整焦点。我常用木星作为参考点进行对焦。</li></ul></li><li><p><strong>白平衡</strong>：</p><ul><li>固定白平衡值，推荐设置在4200K-4600K之间。根据个人喜好调整，低值会偏蓝，高值会偏黄。</li></ul></li><li><p><strong>曝光参数</strong>：</p><ul><li>使用“500法则”计算最长曝光时间：500 ÷ 镜头焦段。例如，使用 50mm定焦镜头，曝光时间应为 10 秒以内。</li><li>ISO 设置在 2000-3200 之间。尽量避免过高的 ISO 值，以减少噪点。</li><li>间隔时间建议 25-30 秒。</li></ul></li><li><p><strong>照片数量</strong>：</p><ul><li>星轨拍摄通常需要大量照片，后期合成星轨效果。例如，拍摄 10秒的延时视频需要至少 240 张照片。</li></ul></li></ol><hr><h4 id="三后期处理-1">三、后期处理</h4><ol type="1"><li><p><strong>初步调整</strong>：</p><ul><li>降低高光，减轻光污染。</li><li>适当增加白色色阶，让星星更加明亮。</li><li>压低黑色色阶，提升星空对比度，但要注意保留前景细节。</li></ul></li><li><p><strong>增强效果</strong>：</p><ul><li>调高清晰度和纹理参数，使星轨更加突出。</li><li>使用“去朦胧”工具，改善画面灰蒙感。</li><li>可用镜像滤镜对银河部分进行局部增强，例如提升室温或偏品红色调。</li></ul></li><li><p><strong>同步设置</strong>：</p><ul><li>调整完成后，可将效果同步到所有照片，确保整个系列风格统一。</li><li>如果有预设，可以直接应用，提高效率。</li></ul></li></ol><hr><h4 id="四总结">四、总结</h4><p>星轨的拍摄是一项既考验耐心又需要细致调整的工作。无论是前期准备还是后期处理，细节的把握都至关重要。希望以上内容能为大家提供帮助，期待你们拍出精彩的星轨作品！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影日记</title>
      <link href="/2024/11/28/%E6%91%84%E5%BD%B1%E5%B1%95/"/>
      <url>/2024/11/28/%E6%91%84%E5%BD%B1%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>计划在这篇日记里记录一些日常摄影。</p><h3 id="瞳孔写真">瞳孔写真</h3><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/瞳孔-8.jpg" alt="瞳孔-8"> <img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/瞳孔-4.jpg" alt="瞳孔-4"></p><h1 id="星空摄影">星空摄影</h1><p><strong>前期准备:</strong></p><p>三脚架，相机，电池或者外接充电宝，内存卡，快门线(相机自带延时功能)</p><p><strong>拍摄准备:</strong>1.找一颗比较明亮的星星然后手动放大对焦(可以使用峰值)2.锁定白平衡4200k-4600k左右3.设定拍摄间隔时间30秒左右拍一张(500法则500除以焦段)iso2000-3200后期制作延时帧数为24，比如说想要拍摄10秒钟的延时视频就需要240张的 照片然后就可以按下快门进行拍摄了。</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1155163094&bvid=BV1hZ421W7PR&cid=1565766372&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h1 id="希区柯克">希区柯克</h1><h2 id="拉近">拉近</h2><p>视频结尾处定格，并将定格图片切入画中画，移动至视频开头，找到不透明度，数值降低。</p><p>主轨结尾处打一个关键帧，视频开头处双手放大视频，并且调整任务重合，删除画中画。</p><h2 id="拉远">拉远</h2><p>视频开始处定格，并将定格图片切入画中画，移动至视频结尾，找到不透明度，数值降低。</p><p>主轨开始处打一个关键帧，视频结尾处双手放大视频，并且调整任务重回，删除画中画。</p><h2 id="2025年1月13-月亮">2025年1月13 月亮</h2><p><img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/DSC06792-2.jpg" alt="DSC06792-2"> <img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/DSC06792-已增强-降噪-1.jpg" alt="DSC06792-已增强-降噪-1"> <img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/DSC06793-3.jpg" alt="DSC06793-3"> <img src="https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/DSC06794-4.jpg" alt="DSC06794-4"></p><h3 id="测试">测试</h3><div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg","alt":""}]</div>    </div>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记</title>
      <link href="/2024/11/27/%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/11/27/%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="面试期间不展示日记-qaq">面试期间，不展示日记 QAQ</h1><!-- # 2024-11-27## 今天做了什么  白天六七点才睡觉，上午收到国家奖学金的修改通知，茫茫慌慌地跑去签字盖章，好麻烦，王老师又来找我弄贫困生的材料，什么是是个头，好累。直接找小王宝贝吃饭了，最近我有些颓废了，小王很优秀，比我有前途多了，我好像走到死胡同了，我也不知道该怎么办了。只是经常难受，我有点在乎别人的看法，我想要其他人理解我。晚上吃了回家吃饭，小王宝贝出的钱98，有些贵，哈哈。  ![](https://raw.gitmirror.com/Withnoidea/PicGoDemo/blog/img/202411272306692.jpg)# 2024/11/28早上8：30起床了, 洗漱，喝药，背单词，上午准备把课程看一下，有时间把项目开始弄了，时间越来越少，其实距离春招也很近了。10：52 背完单词了，用了好久，但是背多少，配置picgo插件，已经可以实现vscode进行书写blog了。越来越方便了，blog暂时不修改样式，开始做项目啦~倒霉，晚上好难过，傻逼王老师有几把找我拉人头，牛马当的时间太久了，大家都觉得这种脏活得我来吗，好难受， 我也有说不的权力，我没有帮他弄，小王宝贝没能理解我，我知道这个不能怪她，我心理真的很希望身边人能理解我，我无法选择找父母和亲人倾诉，小王是我的唯一，害怕有一天会all alone，可能有人会觉得我只是患得患失，但是爱和不爱其实是可以明显感觉到的，一起去拿快递也是等，你自己去回去换衣服，我也是会等的。慢慢来吧。差点压不住怒火。**视频测试**# 2024/11/29上午背了单词，状态开始回升了，戒🦌，课程好想这几天全部弄掉啊，自己好菜，被群里人骂了，我有点发现我自己的问题了，我喜欢别人喂送的知识，自己很难主动学习，好像我一直都是这样。我有一点找到我自己的价值了，我想去做自己做不到的事情，不是去追求遥不可及，是希望自己可以在自己能做的事情上有所突破，去静下心学习自己之前不会的知识，一点点吃透他。加油吧小羊。 --><!-- # 25/4/28搜索与图论终于半入门了，感谢自己认真学习了数组模拟数据结构，栈队列这些，现在没有之前吃力了。晚上打了篮球，按照教程来的，投篮有些强悍了，哈哈，keep going~ --><!-- # 2025/6/3在校的最后几天，舍友在打游戏，目前是麻木的状态，写下这篇日记，不知道未来自己的发展会是怎样。我相信自己会成功实现自己的目标（考研上岸），其实蛮想哭的，目前一事无成，不想让父母担心自己没有工作，不想让学业荒废，四年坚持，在最后放弃，是谁都会觉得我很无能吧，或许有人会说：“杨胜，你大一到大四不是牛逼吗，拿了这么多奖， 考研都坚持不了，你也就这样了，我不说自己考上211了，我就是一本也比你强啊，别人都以为你考研呢，你成绩了，没去考吗，这就放弃了啊，不行啊， 还拿国家奖学金，三好学生呢，就这点出息，垃圾，废物”。我想说：“请你保持愤怒，保持紧绷的状态，直到那只箭射进靶心，前面情感失意，挫折什么的，都是你成长的必经之路，未来你一定比别人顺，比别人走的弯路少，请一直昂扬的走下去吧！。” --><!-- 2025 6 9今天刷视频又看到了复利效应，我想每天进步1%，开始了就不要放弃，每天完成对应任务，晚上打了codeforces div3,还是2题的水平，第三第四确实想不出来了，准备两个月，祝csp ccf成功，不要放弃，你现在很努力了，8 + 16 饮食开始实验，每天9-5进食，今天晚上吃了一点玉米，第一天还可以接受，继续努力~晚上争取搞懂线代习题，有能力的化完成一下习题，数据结构看一下。明天可能算法的时间要稍微少一点了， 408课程每天3小时不能少规划+尝试工作 90  min408 180（90 + 90） min数学 180（90 + 90）英语 90 看一下大概上午 英语 + 数学 三节课的样子，下午408 + 工作 也是3节课，试试吧。时间动态调整 --><p>6/19哭的最凶的一天，泪点一下子降到极值，好兄弟特地送来一捧花，其实开始还只是差异，看到金榜题名，一下子忍不住了。眼泪唰唰的流，四年的苦，只有自己的兄弟看在心里，没想过就这样结束了四年，四年里面成长了很多,思绪在这一刻好像停滞了，有很多苦水想倾倒，最后只向量一句，感谢相遇。<img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250619181406.png" alt="20250619181406"> 6/26凌晨写下这篇日记，前一天晚上聊了很多关于尊重客观规律，利用客观规律的话题，晚上要熬夜看王道的数据结构，争取早起一天，目标好像还是很远呢，什么时候才可以完成算法基础课程，什么时候才能进行提高呢，接受自己的平庸，但是希望自己可以主宰自己的人生，一年后可以接受自己没有上岸92，但是不能接受自己还是麻木的活下去，看着身边的朋友一点点进步，一点点超过自己，我只是手高眼低，达咩<sub>尽快进入状态吧，加油，自己说过的话要争取实现。定下一个目标7月份熟悉cspccf和pat乙，目标参加一次pat85分以上，争取90+，参加一次cspccf,争取300分。目前需要了解题目数量，分值，考点，难易程度，考试时间以及题目时间分配，一周内完成。6/27 喜报！软考程序员初级已拿下！ <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/![20250626191626](httpscdn.jsdelivr.netghWithnoideaimages20250626191626.png).png" alt="20250626191626">目标在一点点靠近呢</sub>发现问题，解决问题，数学做题较慢，下次还是需要计时做题，今天想到将每章自己认为比较难学懂的，距离我和考研水平的地方全部写下来，一点点啃面包啃掉。英语要开始做真题啦，要求最多7天完成一篇真题150/ 7 = 20大概可以完成20套题，要求完整完成，背单词继续两页/200个一天吧，最近时间很紧呢，要加油哦，好好休息，晚上不学习的时候要早一点睡觉。6/28 今天目标完成树相关学习，明天完成习题，并进行图的学习，newtarget：完成数据结构学习后，每天完成一个手撕代码（数据结构大题)争取两周内完成数据结构的学习。数学的进度要快一点了。不过也是有喜报滴，今天数据结构树的题目做起来很顺，目前正确率在80以上。有时间该看一下相关院校的分数线，报录比了，哦~，英语不能落下了。6/28细分目标，目前来说数据结构的视频还有60个左右，想要一周内完成数据结构的学习的话，一天需要学习8个视频左右，制定计划后每天写一下观看的记录。</p><p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="131.222ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 58000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle" fill="red" stroke="red"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">想</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">到</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">问</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">题</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">够</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">话</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(13000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(14000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">先</text></g><g data-mml-node="mi" transform="translate(15000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">过</text></g><g data-mml-node="mi" transform="translate(16000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">进</text></g><g data-mml-node="mi" transform="translate(17000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">度</text></g><g data-mml-node="mi" transform="translate(18000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(19000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">最</text></g><g data-mml-node="mi" transform="translate(20000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">后</text></g><g data-mml-node="mi" transform="translate(21000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">在</text></g><g data-mml-node="mi" transform="translate(22000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">做</text></g><g data-mml-node="mi" transform="translate(23000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">题</text></g><g data-mml-node="mi" transform="translate(24000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(25000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">做</text></g><g data-mml-node="mi" transform="translate(26000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">题</text></g><g data-mml-node="mi" transform="translate(27000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(28000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">过</text></g><g data-mml-node="mi" transform="translate(29000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">程</text></g><g data-mml-node="mi" transform="translate(30000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">中</text></g><g data-mml-node="mi" transform="translate(31000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(32000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">重</text></g><g data-mml-node="mi" transform="translate(33000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">新</text></g><g data-mml-node="mi" transform="translate(34000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">翻</text></g><g data-mml-node="mi" transform="translate(35000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">书</text></g><g data-mml-node="mi" transform="translate(36000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">回</text></g><g data-mml-node="mi" transform="translate(37000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">顾</text></g><g data-mml-node="mi" transform="translate(38000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">知</text></g><g data-mml-node="mi" transform="translate(39000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">识</text></g></g></g><g data-mml-node="mspace" transform="translate(40000,0)"></g><g data-mml-node="mi" transform="translate(40000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(41000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(42000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">这</text></g><g data-mml-node="mi" transform="translate(43000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">样</text></g><g data-mml-node="mi" transform="translate(44000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">说</text></g><g data-mml-node="mi" transform="translate(45000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">不</text></g><g data-mml-node="mi" transform="translate(46000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">定</text></g><g data-mml-node="mi" transform="translate(47000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">就</text></g><g data-mml-node="mi" transform="translate(48000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">可</text></g><g data-mml-node="mi" transform="translate(49000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">以</text></g><g data-mml-node="mi" transform="translate(50000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(51000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">增</text></g><g data-mml-node="mi" transform="translate(52000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">加</text></g><g data-mml-node="mi" transform="translate(53000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(54000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">些</text></g><g data-mml-node="mi" transform="translate(55000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">记</text></g><g data-mml-node="mi" transform="translate(56000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">忆</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(57000,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g></g></g></svg></mjx-container></span></p><table><thead><tr><th>序号</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>5.3.2.1线索二叉树的概念</td><td>✔️</td></tr><tr><td>2</td><td>5.3.2_2_二叉树的线索化</td><td>代码实现目前比较糊涂</td></tr><tr><td>3</td><td>5.3.2_3_在线索二叉树中找前驱后继</td><td>重点在于会推，强化阶段代码要自己写一编</td></tr><tr><td>4</td><td>5.4.1 树的存储结构</td><td>✔️</td></tr><tr><td>5</td><td>5.4.2 树、森林与二叉树的转换</td><td>✔️理解原理&gt;&gt;方法 左边村第一个孩子，右边存兄弟</td></tr><tr><td>6</td><td>5.4.3 树和森林的遍历</td><td>✔️</td></tr><tr><td>7</td><td>5.5.1_哈夫曼树</td><td>✔️习题！</td></tr><tr><td>8</td><td>5.5.2_1_并查集</td><td>✔️</td></tr><tr><td>9</td><td>5.5.2_2_并查集的进一步优化</td><td>✔️代码理解，复杂度分析</td></tr></tbody></table><ul><li>浙江大学计算机程序设计能力考试（<code>Programming Ability Test</code>）</li><li>考试时间：每年三次，3，8，11月</li><li>甲乙两个等级，考试三个小时😴，成绩当场出，证书当场领😍。</li><li>甲级共四题，分数为：20、25、25、30。</li><li>乙级共五题，分数为：15、20、20、20、25。（每题不超过30min）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/image-20250628205448944.png" alt="image-20250628205448944"></p><h3 id="程序设计能力测评---乙级-考生应具备以下基本能力">程序设计能力测评- 乙级 考生应具备以下基本能力：</h3><ol type="1"><li>使用至少一种编程语言(请参考 https://pintia.cn/samples的“各种语言程序样例”)进行代码设计的基本能力，以及相关开发环境的基本调试技巧；</li><li>理解并掌握最基本的数据存储结构，即：数组、链表；</li><li>理解并熟练编程实现与基本数据结构相关的基础算法，包括递归、排序、查找等；</li><li>能够分析算法的时间复杂度、空间复杂度和算法稳定性；</li><li>具备问题抽象和建模的初步能力，并能够用所学方法解决实际问题。</li></ol><h3 id="程序设计能力测评---甲级-在达到乙级要求的基础上还要求">程序设计能力测评- 甲级 在达到乙级要求的基础上，还要求：</h3><ol type="1"><li>具有充分的英文阅读理解能力；</li><li>理解并掌握基础数据结构，包括：线性表、树、图；</li><li>理解并熟练编程实现经典高级算法，包括哈希映射、并查集、最短路径、拓扑排序、关键路径、贪心、深度优先搜索、广度优先搜索、回溯剪枝等；</li><li>具备较强的问题抽象和建模能力，能实现对复杂实际问题的模拟求解。</li></ol><h3 id="程序设计能力测评---顶级-在达到甲级要求的基础上还要求">程序设计能力测评- 顶级 在达到甲级要求的基础上，还要求：</h3><ol type="1"><li>对高级、复杂数据结构掌握其用法并能够熟练使用，如后缀数组、树状数组、线段树、Treap、静态KDTree等；</li><li>能够利用经典算法思想解决较难的算法问题，如动态规划、计算几何、图论高级应用（包括最大流/最小割，强连通分支、最近公共祖先、最小生成树、欧拉序列）等，并灵活运用；</li><li>能够解决复杂的模拟问题，编写并调试代码量较大的程序；</li><li>具有缜密的科学思维，考虑问题周全，能够正确应对复杂问题的边界情况。</li></ol><hr>emm 距离自己定义的7天一套英语卷子过了两天咯，一定要开始了，晚上找到了剑指offer的题单，acwing上有免费的讲解，一共70题，抽空要做掉。<p>6/29</p><p>进度</p><table><thead><tr><th>序号</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>6.1.1_图的基本概念</td><td>✔️</td></tr><tr><td>2</td><td>6.2.1_邻接矩阵法</td><td>✔️</td></tr><tr><td>3</td><td>6.2.2_邻接表法</td><td>✔️</td></tr><tr><td>4</td><td>6.2.3+6.2.4_十字链表、邻接多重表</td><td>✔️相关图需要加深印象</td></tr><tr><td>5</td><td>6.2.5_图的基本操作</td><td>✔️时空复杂度需要理解</td></tr><tr><td>6</td><td>6.3.1_图的广度优先遍历</td><td>✔️</td></tr><tr><td>7</td><td>6.3.2_图的深度优先遍历</td><td>✔️</td></tr><tr><td>8</td><td></td><td></td></tr><tr><td>9</td><td></td><td></td></tr><tr><td>10</td><td></td><td></td></tr></tbody></table><p>6/30 马上踏入七月了，只有五个月了，一起打卡的兄弟今天忘记打卡了呢，上午做了数据结构的题目，总体来说还是蛮难的。要专注一些了，之前好像是利用碎片化玩手机，主动一点吧兄弟，尽量利用碎片化时间多看看数学吧，加油！！！7/4看到6/30的日记还蛮有感触呢，数据结构已经到最后一章了，图还有一部分习题没有完成，总的来说状态我还是比较能接受的，数据结构题目和数学的题目做起来好像没那么棘手了，不过有一些地方还是需要警惕，基础1000题和660不能拖着，要尽快开始强化了，概率论有时间要和高数并行学习，408课程看的有点反感了可能，很正常，抵触的地方可以多看看书。ennn，嘿嘿，今天日记是有记录想展示哦！已经完成了英语单词一轮的背诵，加油！嘿嘿，最近真题做的没那么勤快，后面几天希望调整一下，其他的按计划进行下去吧，加油，你必上岸。<img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/IMG_1021.jpg" alt="IMG_1021"> 7/7 <img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/20250707102458.png" alt="20250707102458"> https://www.100dc.com/xll/243425.html有种吊着一口气可以舒缓一下的感觉，无限进步<a href="https://gsas.seu.edu.cn/ssmlcx2024/pages/index.html">招生目录</a></p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1451251684&bvid=BV1mi421o7qo&cid=1457984528&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="78">7/8</h2><p>可恶，快到七月中旬了，怎么这两天反而不在状态，积分章节题目错好多，还不太愿意思考了呢，老兄，坚持住呀，还有几个月呢，总归来得及的，静下心来一点点吃透题目呀，别太浮躁。晚上继续做数学和数据结构，不要太着急赶进度，学会了才是最重要的，别着急你是140分的苗子（没说150怕你骄傲）。</p><h2 id="79">7/9</h2><p>上午起来还是有点静不下心，早饭的时候玩了手机，七七八八的事情不再描述，定个今天的target吧，数学完成第九章计算的批改，来得及往后一章，408一如既往的过进度，今天继续数据结构查找和排序部分，红黑树平衡二叉树的建立插入删除一定要弄明白，就这么多吧。</p><h2 id="724">7/24</h2><p>有一段时间没有写日记了，还记得最开始做这个博客就是为了记录自己的生活学习情况，主旋律还是向上的，“提笔”的一瞬间，负面的想法突然充斥进我的大脑。学习上，总体来说，算是按照计划来到，有些许浮动，不过状态还可以，数学，408，英语也都在按照计划进行，有一点拖，不过还能接受，我相信在那一天到来前，大家都是准备活动，准备活动怎么做都不为过，但不至于影响比赛，嗯嗯，大家都一起起跑（我指的是开考那一天，机试方面有些拖沓，在做30-40题左右，进度有些停滞了，不过好在还有时间，不需要为打翻的牛奶悲伤，当然也算不上牛奶，更就替补上打翻了，一切的一切都在往好的方向发展，嗯，该去上面看看了；生活上，家里妈妈的眼睛还是困扰着他，老爸也是一声不吭的默默工作，有时候想和他沟通，有时候看到他无理的发火，想到他暴戾的样子，又觉得多一事不如少一事。作息在慢慢调整，身边的人在一点点引导着我，引导我走向那本该属于我的辉煌，去！去高处看看，那的风景比这全（whatevergood or bad )。</p><h2 id="725">7/25</h2><p>今天状态比较差，罪魁祸首是睡眠不足，两点半还没睡，看视频…带来的一系列连锁反应，后果还是太严重了，上午又忘带了强化的书籍，题目做了一章，16章还留了三个题目，数学做题思路还是不灵光，不过基本盘还是保住了，基础题似乎正确率搞了一点，408进度还算可以，能在7月基本完成计算机组成原理的学习，英语要每天多花点时间了，最近英语都还没怎么做题，朝着目标前进吧~</p><h2 id="731">7/31</h2><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=114928560113062&bvid=BV1Yu8Lz4EZV&cid=31326340931&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><p><img src="https://cdn.jsdelivr.net/gh/Withnoidea/images/01af5f6754ac4de9d09fb4ba55a75f1.png" alt="01af5f6754ac4de9d09fb4ba55a75f1"></p><ol type="1"><li>学习方法</li><li>学习效率</li><li>学会思考</li><li>动机</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
